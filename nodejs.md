## nodejs

曾闻,对一门语言的熟悉程度,就是看是否熟悉它的api。鉴于此,来收集一下node.js的api。简单来说就是看看nodejs有啥用。

有啥用,先创建一堆文件夹,用来做装demo的文件夹。

```js
const fs = require("fs")
const path = require("path")

let folders = ['assert', 'buffer', 'child_process', 'cluster', 'console', 'crypto', 'dgram', 'dns', 'error', 'fs', 'global', 'http', 'https', 'module', 'net', 'os', 'path', 'process', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'timer', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib']

let recursiveMkfolder = (function () {
    let pathCache = [];
    let pathStr = "";
    return function (path) {
        let pathArray = path.split('\\');
        pathArray.forEach(function (value, index) {
            pathStr = pathArray.slice(0,index+1).join("\\");
            if (!pathCache.includes(pathStr)) {
                // console.log(!pathCache.includes(pathStr));
                count++
                try{
                fs.mkdirSync(pathStr)
                }catch(e){
                }
                pathCache.push(pathStr);
            }
        })
        // console.log(pathCache);
    }
})()
folders.forEach((value) => {
    let folderPath = path.join(__dirname, "demos/", value);
    recursiveMkfolder(folderPath)
})
```

- mkdir这个方法，本身是不会一层层建立路径，如果终末文件夹的父文件夹不存在，就会报错，所以需要从头开始一层层建立.就用遍历的方法，把路径拆分
- 拆分之后用了缓存，
- try{}catch(){}可以让代码报错也执行下去，因为这里存在了之后是必定报错
- 异步的方法本身会捕捉错误，但异步之后文件夹的建立顺序会错乱，如果子文件夹在父文件夹之前建立，即使捕捉错误也建立不了
- 如果从面建立文件夹，然后报错了再往前面建立，等不报错再往后面建立，这个倒也可以.



--------

## mongodb

(明白该领域的概念，就算理解错了，也要建立好联系，之后可以纠正)

### 概念

简单理解，数据库是存放数据的东西，和笔记本，excel表之类的东西差不多。但数据库的作用肯定是大得多，对增删改查做了优化，在处理这些操作时，一个好的数据库，既要速度快，还得保证不出错。

- SQL（structured query lauguage ) 结构化查询语言

一种语言，也是一种标准，用来管理数据库。





关系型数据库:遵循ACID(酸)原则，记忆的时候可以理解为关系型数据库很酸，比较苛刻，严格。



- 事务

[数据库事务-百度百科](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin)

事务本身就是遵循ACID原则的一系列操作，如果不遵循这些操作，也称不上为“事务”。



- 原子性（atomicity)

> 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 

原子性意味着这东西不可分割，就是说一个操作看起来分成两步或者多步，但每一步都会检测其他步骤是否完成，其中一个失败则全体失败。

> （进程崩溃，断电，网络故障，硬盘满，违反约束等） 

上面的东西是造成事务失败的例子。

- 一致性(consistency)

> 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
>
> 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。

上面的解释，看起来和原子性没什么区别，感觉不太好理解。

> 保证数据库的一致性是数据库管理系统的一项功能.比如有两个表(员工\职位),员工表中有员工代码、姓名、职位代码等属性，职位表中有职位代码、职位名称、职位等级等属性。你在其中员工表中进行了插入操作,你插入了一个新员工的信息，而这个新员工的职位是公司新创建的一个职位。如果没有一致性的保证，就会出现有这么一个员工，但是不知道他到底担当什么职责！这个只是它的一个小小方面。 

这里大致是，员工表的职位数据要和职位表中的职位对应上，如果没有对应上，说明哪里出了问题。这里的“一致性”解释更合理。

其约束性就是两个职位代码要对应。员工表增加之后，仍然要被约束，则要在职位表上建立对应职位。

> 用户a执行查询操作，需要3分钟，而用户b在3分钟内的某一刻修改了数据，问用户a看到的数据是否被修改所影响。答案是不影响。

如果需要造成影响，那么查询操作也许需要重新开始查询，因为程序不知道修改的数据是否存在于已经查询的数据中。但这个道理是否属于一致性的范畴？

如果花3分钟去修改数据，而你读取的话，肯定也不能读取修改中途的数据，因为万一要回滚，则数据就出错了。

> 有人认为，一致性是强加在ACID里凑数的。因为这个东西不是数据库要保证的，而是应用程序需要定义和关注的。有一些道理。
>
>  我们经常认为，主外键约束达成了某种一致性，你不能在子表里面插入父表没有的键值，这是数据库给保证了一致性，但是这种一致性也是根据业务由开发人员定义的。如果你向数据库插入违反业务逻辑的假数据，数据库并没有这种约束阻止你。所以，一致性是通过事务的其他特性(原子性，隔离性）达成的，它并不属于数据库和事务的属性。 

确实这种约束由开发人员定义，数据库本身不存在知道哪些数据会有依赖。

- 隔离性（独立性）（isolation） 

> 隔离性保证同时执行的事务是相互隔离的，它们不能互相影响。简言之，一个事务只能看到另一个事务开始之前或者结束之后的结果，不能看到任何中间状态，反之亦然。
>
> 结果就如同他们串行化（Serializability）完成一样，尽管实际上它们是并发运行的。隔离性分好几种级别，每一种隔离级别都在权衡性能和某种安全保障，This is a kind of trade-off.

上面的解释挺清楚了，如果同时修改某个数据，并行的事务要像串行一样，不会相互影响

- 持久性（durability）

所以关系数据库只能用磁盘来保存，而非关系型还会使用内存。为了保存，还会设置日志和归档日志，反正会想办法一直保存。

### 并发的问题

> 2．并发控制概述
>
> 事务是并发控制的基本单位，保证事务ACID的特性是事务处理的重要任务，而并发操作有可能会破坏其ACID特性。
>
> DBMS并发控制机制的责任：
>
> 对并发操作进行正确调度，保证事务的隔离性更一般，确保数据库的一致性。
>
> 如果没有锁定且多个用户同时访问一个数据库，则当他们的事务同时使用相同的数据时可能会发生问题。由于并发操作带来的数据不一致性包括：丢失数据修改、读”脏”数据（脏读）、不可重复读、产生幽灵数据。

- 数据丢失。同时修改通一个文档的时候，如果不搞好，最后一个会覆盖前面所有的。就像git里面的操作，当你提交前要记得pull。
- 脏数据。修改的过程中，数据被其他事务读取到了，保存之后当做最终版本，则之前被读取的数据为脏数据。如果加锁，则解决问题。
- 不可重复读。是在有修改的情况下。
- 产生幽灵数据。

### 附加参考

[关系型数据库事务一：概念](https://www.cnblogs.com/nativestack/p/ricky_datasys01.html)

[关系型数据库事务二：隔离级别](https://www.cnblogs.com/nativestack/p/ricky_datasys02.html)

事务隔离，如果并发变成串行就都解决了。。说得好。

关系型数据库很像git的精神



## 后端开发记录

### 创建目录



### mongodb连接

| Oracle                        | MongoDB          | Mongoose                 |
| ----------------------------- | ---------------- | ------------------------ |
| 数据库实例(database instance) | MongoDB实例      | Mongoose                 |
| 模式(schema)                  | 数据库(database) | mongoose                 |
| 表(table)                     | 集合(collection) | 模板(Schema)+模型(Model) |
| 行(row)                       | 文档(document)   | 实例(instance)           |
| rowid                         | _id              | _id                      |
| Join                          | DBRef            | DBRef                    |

> 通过上面的阐述,我们大概能知道了在Mongoose里面有哪几个基本概念。
>
> - Schema: 相当于一个数据库的模板。 Model可以通过mongoose。model 集成其基本属性内容。 当然也可以选择不继承。
> - Model: 基本文档数据的父类,通过集成Schema定义的基本方法和属性得到相关的内容。
> - instance: 这就是实实在在的数据了。 通过 new Model()初始化得到。
>
> 他们各自间是怎样的关系呢？ 下图可以清晰的说明, 以上3中实际上就是一个继承一个得到最后的数据





### api

根据功能来划分api?