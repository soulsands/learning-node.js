## nodejs

曾闻,对一门语言的熟悉程度,就是看是否熟悉它的api。鉴于此,来收集一下node.js的api。简单来说就是看看nodejs有啥用。

有啥用,先创建一堆文件夹,用来做装demo的文件夹。

```js
const fs = require("fs")
const path = require("path")

let folders = ['assert', 'buffer', 'child_process', 'cluster', 'console', 'crypto', 'dgram', 'dns', 'error', 'fs', 'global', 'http', 'https', 'module', 'net', 'os', 'path', 'process', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'timer', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib']

let recursiveMkfolder = (function () {
    let pathCache = [];
    let pathStr = "";
    return function (path) {
        let pathArray = path.split('\\');
        pathArray.forEach(function (value, index) {
            pathStr = pathArray.slice(0,index+1).join("\\");
            if (!pathCache.includes(pathStr)) {
                // console.log(!pathCache.includes(pathStr));
                count++
                try{
                fs.mkdirSync(pathStr)
                }catch(e){
                }
                pathCache.push(pathStr);
            }
        })
        // console.log(pathCache);
    }
})()
folders.forEach((value) => {
    let folderPath = path.join(__dirname, "demos/", value);
    recursiveMkfolder(folderPath)
})
```

- mkdir这个方法，本身是不会一层层建立路径，如果终末文件夹的父文件夹不存在，就会报错，所以需要从头开始一层层建立.就用遍历的方法，把路径拆分
- 拆分之后用了缓存，
- try{}catch(){}可以让代码报错也执行下去，因为这里存在了之后是必定报错
- 异步的方法本身会捕捉错误，但异步之后文件夹的建立顺序会错乱，如果子文件夹在父文件夹之前建立，即使捕捉错误也建立不了
- 如果从面建立文件夹，然后报错了再往前面建立，等不报错再往后面建立，这个倒也可以.



--------

## mongodb

(明白该领域的概念，就算理解错了，也要建立好联系，之后可以纠正)

### 概念

简单理解，数据库是存放数据的东西，和笔记本，excel表之类的东西差不多。但数据库的作用肯定是大得多，对增删改查做了优化，在处理这些操作时，一个好的数据库，既要速度快，还得保证不出错。

- SQL（structured query lauguage ) 结构化查询语言

一种语言，也是一种标准，用来管理数据库。





关系型数据库:遵循ACID(酸)原则，记忆的时候可以理解为关系型数据库很酸，比较苛刻，严格。



- 事务

[数据库事务-百度百科](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin)

事务本身就是遵循ACID原则的一系列操作，如果不遵循这些操作，也称不上为“事务”。



- 原子性（atomicity)

> 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 

原子性意味着这东西不可分割，就是说一个操作看起来分成两步或者多步，但每一步都会检测其他步骤是否完成，其中一个失败则全体失败。

> （进程崩溃，断电，网络故障，硬盘满，违反约束等） 

上面的东西是造成事务失败的例子。

- 一致性(consistency)

> 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
>
> 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。

上面的解释，看起来和原子性没什么区别，感觉不太好理解。

> 保证数据库的一致性是数据库管理系统的一项功能.比如有两个表(员工\职位),员工表中有员工代码、姓名、职位代码等属性，职位表中有职位代码、职位名称、职位等级等属性。你在其中员工表中进行了插入操作,你插入了一个新员工的信息，而这个新员工的职位是公司新创建的一个职位。如果没有一致性的保证，就会出现有这么一个员工，但是不知道他到底担当什么职责！这个只是它的一个小小方面。 

这里大致是，员工表的职位数据要和职位表中的职位对应上，如果没有对应上，说明哪里出了问题。这里的“一致性”解释更合理。

其约束性就是两个职位代码要对应。员工表增加之后，仍然要被约束，则要在职位表上建立对应职位。

> 用户a执行查询操作，需要3分钟，而用户b在3分钟内的某一刻修改了数据，问用户a看到的数据是否被修改所影响。答案是不影响。

如果需要造成影响，那么查询操作也许需要重新开始查询，因为程序不知道修改的数据是否存在于已经查询的数据中。但这个道理是否属于一致性的范畴？

如果花3分钟去修改数据，而你读取的话，肯定也不能读取修改中途的数据，因为万一要回滚，则数据就出错了。

> 有人认为，一致性是强加在ACID里凑数的。因为这个东西不是数据库要保证的，而是应用程序需要定义和关注的。有一些道理。
>
>  我们经常认为，主外键约束达成了某种一致性，你不能在子表里面插入父表没有的键值，这是数据库给保证了一致性，但是这种一致性也是根据业务由开发人员定义的。如果你向数据库插入违反业务逻辑的假数据，数据库并没有这种约束阻止你。所以，一致性是通过事务的其他特性(原子性，隔离性）达成的，它并不属于数据库和事务的属性。 

确实这种约束由开发人员定义，数据库本身不存在知道哪些数据会有依赖。

- 隔离性（独立性）（isolation） 

> 隔离性保证同时执行的事务是相互隔离的，它们不能互相影响。简言之，一个事务只能看到另一个事务开始之前或者结束之后的结果，不能看到任何中间状态，反之亦然。
>
> 结果就如同他们串行化（Serializability）完成一样，尽管实际上它们是并发运行的。隔离性分好几种级别，每一种隔离级别都在权衡性能和某种安全保障，This is a kind of trade-off.

上面的解释挺清楚了，如果同时修改某个数据，并行的事务要像串行一样，不会相互影响

- 持久性（durability）

所以关系数据库只能用磁盘来保存，而非关系型还会使用内存。为了保存，还会设置日志和归档日志，反正会想办法一直保存。

### 并发的问题

> 2．并发控制概述
>
> 事务是并发控制的基本单位，保证事务ACID的特性是事务处理的重要任务，而并发操作有可能会破坏其ACID特性。
>
> DBMS并发控制机制的责任：
>
> 对并发操作进行正确调度，保证事务的隔离性更一般，确保数据库的一致性。
>
> 如果没有锁定且多个用户同时访问一个数据库，则当他们的事务同时使用相同的数据时可能会发生问题。由于并发操作带来的数据不一致性包括：丢失数据修改、读”脏”数据（脏读）、不可重复读、产生幽灵数据。

- 数据丢失。同时修改通一个文档的时候，如果不搞好，最后一个会覆盖前面所有的。就像git里面的操作，当你提交前要记得pull。
- 脏数据。修改的过程中，数据被其他事务读取到了，保存之后当做最终版本，则之前被读取的数据为脏数据。如果加锁，则解决问题。
- 不可重复读。是在有修改的情况下。
- 产生幽灵数据。

### 附加参考

[关系型数据库事务一：概念](https://www.cnblogs.com/nativestack/p/ricky_datasys01.html)

[关系型数据库事务二：隔离级别](https://www.cnblogs.com/nativestack/p/ricky_datasys02.html)

事务隔离，如果并发变成串行就都解决了。。说得好。

关系型数据库很像git的精神



## 后端开发记录

### 创建目录



### mongodb连接

| Oracle                        | MongoDB          | Mongoose                 |
| ----------------------------- | ---------------- | ------------------------ |
| 数据库实例(database instance) | MongoDB实例      | Mongoose                 |
| 模式(schema)                  | 数据库(database) | mongoose                 |
| 表(table)                     | 集合(collection) | 模板(Schema)+模型(Model) |
| 行(row)                       | 文档(document)   | 实例(instance)           |
| rowid                         | _id              | _id                      |
| Join                          | DBRef            | DBRef                    |

> 通过上面的阐述,我们大概能知道了在Mongoose里面有哪几个基本概念。
>
> - Schema: 相当于一个数据库的模板。 Model可以通过mongoose。model 集成其基本属性内容。 当然也可以选择不继承。
> - Model: 基本文档数据的父类,通过集成Schema定义的基本方法和属性得到相关的内容。
> - instance: 这就是实实在在的数据了。 通过 new Model()初始化得到。
>
> 他们各自间是怎样的关系呢？ 下图可以清晰的说明, 以上3中实际上就是一个继承一个得到最后的数据





## 目前理解

理解非关系型数据库， 感觉还是要了解关系型数据库。

目前很多文章基本上是以理解关系型数据库为前提，大概是因为学校里面会学这个，大多数人从关系型数据库理解起。

理解一个新的概念，必须要和已有概念链接起来，谨记。

事物的出现，必定是为了解决特定问题的。解决问题的同时，本身也会引出问题。而如何解决多出来的问题，也会有占用很多篇幅。

关系型数据库如果有个核心点，抽象到数据库层面，首先他是个数据库。目的是为了管理数据。增删改查。所谓数据是一个逻辑起点。以数据为基础，延伸到数据库的方方面面。

数据是客体，而人是主体，数据库是为了满足人对数据的需求，而使用的工具。人对数据有什么需求？就朴素想法而言，可以有下面需求。

我需要把信息储存起来。我可以用笔，做笔记。但这样的做法问题在于

1. 写起来太慢了。
2. 并且难以有规律的输入。
3. 很可能写错。
4. 还有可能写重复。
5. 写了之后容易丢。
6. 查询数据很难。
7. 整理数据很难，难有效做有规律的加工。

在计算机出现之前，大部分的信息保存方式大概都是文字这样记录。包括普通人的日记，官方的编年史，生意人的账簿等等。其中常见并且有效率的保存方式应该是生意人的账簿，或者说会计系统。

会计系统在手工层面就已经非常成熟，通过设置恰如其分的科目，资金的流向和某一刻的情况都可以正确的反应。但会计的方式本身是牺牲了录入速度来换取正确性和检索效率。

这种方式自古以来有之，包括各种案宗卷宗，家谱，科研材料：严格遵守某种编码方式来输入数据，从而在提取数据的时候拥有便利。这个也是自然而然，就像语言一样，本质上是为了效率。就像语言不通的人可以手脚并用来互相沟通，但通过语言，共同遵守某种协议，交流可以顺利进行，就像雪山融化而成的溪。而协议，或说编码，也是这个世界的进化。

协议是乘法。

下面来看看，数据库拥有哪些协议，用以解决哪些管理数据而生的问题。

和人一样，计算机处理一个事情需要多方面配合的，cpu，内存和硬盘。但同时是个严格的人，收到指令之后就是死脑筋去做。

1. 原子性（atomicity)，原子性。比如可能因为太累，高血压突发，饿死，纸突然写满了，各种原因写不下去。这时候要取消写了一个半的内容，还原到之前的状态。大概像是另外一个人在监督，或者纸上面设定一个装置，如果这个人按了开始键没有按结束键，那在这段时期内，数据更改并不生效。
2. 隔离性（isolation)。一起写一本书或者做账的时候，当一个内容不能被同时修改的时候，就需要隔离，通过限制访问。从门口拿了钥匙开了门，进去之后处理完，再把钥匙放回原位。当然这是最严重的隔离，而如果有些数据可以一起处理，那或者可以一同进房间处理。
3. durability。持久性。如果写的人突然暴毙，数据还是不能丢。

---

从作用来看，写起来太慢了。可以通过提高人的性能和熟练度来增加，也可以改变数据的处理方式。就是好的数据库和机器。

有规律的输入，这个拥有了计算机语言肯定不在话下。

如果担心写错，在有很多协议的情况下可以尝试保证，制定一致性规则，但很多时候还是会写错。

重复的情况也一样解决。

至于查询和整理，本质上是一回事，需要通过结构的设计来提高效率。就像设计会计系统和图书管理系统。

总之，电脑数据库的出现尽量保证了客观因素的失误，并且可以通过一定验证规则来防止主观性的失误（一致性），是目前储存数据非常成熟的方式，各种各样的数据库让这个世界有规律地运行。

---------

昨天看了sql的语法，了解了增删改查的语法，但还欠缺对概念的认识。

就数据操作语言（DML)的语法而言，可以总结为定位和操作。先找到合适的定位，然后增删改查的操作，而语法遵循的是`编码中的可以省略的部分终将被省略` ，定位是用逻辑来定位的，比如数字大于，等于，小于，不等于，某个等于另一个可能或者不等于。总之，没有抽离逻辑的范畴。

今天看mongodb的概念，可和RDBMS比较一下。

关系数据库有时候在设计时候会分开，通过一个主键来将不同的表联合起来。

------

> 文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 

关系数据库中会像excel表中一样，在创建的时候需要指定列的类型。而mongodb不需要，意味着更少的限制，是否说明在提取的时候会更麻烦？因为不能提前知道类型。（怎么感觉又有点javascript动态语言的意思)

其实从这个限制来看，mongodb的集合确实不能用表来形容了。表本身倾向有规范有规律的信息，而集合中的文档可以有不同结构，相同的列也不需要是相同类型。所以，命名恰合概念。

> 1. 文档中的键/值对是有序的。
> 2. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。
> 3. MongoDB区分类型和大小写。
> 4. MongoDB的文档不能有重复的键。
> 5. 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。

如果熟悉js可能会将json和对象类别，这里要说明的是键值对是有序的。

而区分大小写和不能有重复，这里和js的对象一致。

> 集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。
>
> 集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。

实际上类似的地方只在于集合和表共同处于数据库的这一层级，里面的功能和限制差别很大。后面也说明，可以插入不同格式和类型。

> ### capped collections

翻译可以盖盖子的集合，在创建的时候限制的大小，当文档数据插入超过这个大小时候就覆盖之前的数据。速度快，推荐用于固定大小的日志和某些缓存信息。

> 数据类型...

数据类型很多，甚至包括数组，对象（内嵌文档），code，正则，一些怪怪的类型。

目前不知道要如何储存，最终应该还是会转换成字符串去储存吧，再通过指定的类型。



> **注意:** 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 

实际测试中，创建数据库也是如此，有数据了才会显示数据库。

`世界标准时 UTC` 

----------

虽说数据库是增删改查，但其中的操作可谓变化贼多。

这几个操作，首先都要定位，即找到需要操作的东西。

- 插入文档：直接从集合中插入即可。

更新文档，有update和save方法。update侧重在已有的数据上修改，而save强调用新的文档替换整个旧的文档，替换是通过指定_id来实现的。

在更新时候，如果没找到选定的记录，是否要当做新文档插入？这是个选项。

更新多条记录呢？这也是选项。

- 查询文档

也是从逻辑角度来判断的。即等于或者不等，另外包括大于小于和等于的4种组合。也可以通过and和or来组合，and就用逗号，or需要一个需要$or。在这里没有创造新的符号，整个语言风格非常像js。

- 可以指定值的类型
- limit和skip用来读取的时候限制和跳过某些数据。这些肯定是需求才出现的。
- 排序
- 索引

索引的实现大概是意味着某种排序，就是对数据先行进行整理。如同给一本书添加目录，从而在找内容时加快速度。如果是找数字，或者英文字母排序的，大概类似先按顺序排好。这样继续寻找时可以通过一些辅助算法，比如先从中间找，然后判断顺序，再从进一步位置的中间找。

- 聚合（aggregate ）

似乎跟合起来关系不大，真要说有什么合起来，只是一些操作，就像之前说的sor,skip,limit排序都成为聚合操作一种。这些操作集合起来肯定实现很变态的操作了。

- 复制

  看起来是备份用的，并不做太多用处。

- 分片

恐怖，设置集群的，用来搞分布式拓展的。这个好像也是mongodb的优势之一。



---

说是mongodb高级内容

- 关系

  `文档之间的关系` 

  如果要引用，先通过讲另一个集合的id，来当做当前集合一个键值对，再通过id去查询另一张表得出结果。和关系数据库差不多。

- 数据库引用

DBrefs算是一种自动引用，将其都当做变量，而关系一栏中讲的方式是手动引用。这个自动引用是通过



-----

## Mongoose

> Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. 

schema可以是模式，概要的意思，在这里用来作为collection格式的定义。schema是mongoose对象上的一个方法，本身又是构造函数，通过构造函数来创建schema。schema的作用很大。

> Schemas not only define the structure of your document and casting of properties, they also define document [instance methods](https://mongoosejs.com/docs/guide.html#methods), [static Model methods](https://mongoosejs.com/docs/guide.html#statics), [compound indexes](https://mongoosejs.com/docs/guide.html#indexes), and document lifecycle hooks called [middleware](https://mongoosejs.com/docs/middleware.html). 

这个





### api

根据功能来划分api?



`node --inspect app.js` ,这种方式